/*
 * SPDX-FileCopyrightText: Axelor <https://axelor.com>
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
package com.axelor.studio.service.constructor.reporting;

import static com.axelor.utils.MetaJsonFieldType.JSON_MANY_TO_ONE;
import static com.axelor.utils.MetaJsonFieldType.MANY_TO_ONE;
import static com.axelor.utils.MetaJsonFieldType.ONE_TO_ONE;

import com.axelor.common.Inflector;
import com.axelor.i18n.I18n;
import com.axelor.meta.CallMethod;
import com.axelor.meta.db.MetaField;
import com.axelor.meta.db.MetaJsonField;
import com.axelor.meta.db.MetaJsonRecord;
import com.axelor.meta.db.MetaModel;
import com.axelor.meta.db.MetaView;
import com.axelor.meta.db.repo.MetaModelRepository;
import com.axelor.meta.loader.XMLViews;
import com.axelor.meta.schema.ObjectViews;
import com.axelor.studio.db.Filter;
import com.axelor.studio.db.StudioChart;
import com.axelor.studio.exception.StudioExceptionMessage;
import com.axelor.studio.service.StudioMetaService;
import com.axelor.studio.service.constructor.GroovyTemplateService;
import com.axelor.studio.service.filter.FilterCommonService;
import com.axelor.studio.service.filter.FilterSqlService;
import com.google.common.base.Joiner;
import com.google.inject.Inject;
import jakarta.xml.bind.JAXBException;
import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class generate charts using ViewBuilder and chart related fields. Chart xml generated by
 * adding query, search fields , onInit actions..etc. All filters with parameter checked will be
 * used as search fields.
 */
public class StudioChartServiceImpl implements StudioChartService {
  protected static final String TEMPLATE_PATH = "templates/chart.tmpl";

  protected static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

  protected static final String Tab1 = "\n \t";
  protected static final String Tab2 = "\n \t\t";
  protected static final String Tab3 = "\n \t\t\t";
  protected static final List<String> dateTypes =
      Arrays.asList("DATE", "DATETIME", "LOCALDATE", "LOCALDATETIME", "ZONNEDDATETIME");
  protected static final List<String> CLICK_HANDLER_SUPPORTED_CHARTS =
      Arrays.asList("bar", "hbar", "scatter", "pie", "donut");

  protected List<HashMap<String, Object>> searchFields;

  protected List<String> joins;

  protected String categType;

  protected MetaModelRepository metaModelRepo;

  protected FilterSqlService filterSqlService;
  protected FilterCommonService filterCommonService;
  protected StudioMetaService metaService;
  protected GroovyTemplateService groovyTemplateService;

  @Inject
  public StudioChartServiceImpl(
      MetaModelRepository metaModelRepo,
      FilterSqlService filterSqlService,
      FilterCommonService filterCommonService,
      StudioMetaService metaService,
      GroovyTemplateService groovyTemplateService) {
    this.metaModelRepo = metaModelRepo;
    this.filterSqlService = filterSqlService;
    this.filterCommonService = filterCommonService;
    this.metaService = metaService;
    this.groovyTemplateService = groovyTemplateService;
  }

  /**
   * Root Method to access the service it generate AbstractView from ViewBuilder.
   *
   * @param studioChart StudioChart object.
   * @throws JAXBException
   */
  @Override
  public void build(StudioChart studioChart) throws JAXBException {

    if (studioChart.getName().contains(" ")) {
      throw new IllegalStateException(I18n.get(StudioExceptionMessage.STUDIO_CHART_1));
    }

    searchFields = new ArrayList<>();
    //		onNewFields = new ArrayList<RecordField>();
    joins = new ArrayList<>();
    categType = "text";

    Map<String, Object> queryMap = prepareQuery(studioChart);
    //		setOnNewAction(studioChart);

    String xml = createXml(studioChart, queryMap);

    log.debug("Chart xml: {}", xml);

    ObjectViews chartView = XMLViews.fromXML(xml);

    MetaView metaView = metaService.generateMetaView(chartView.getViews().getFirst());

    if (metaView != null) {
      studioChart.setMetaViewGenerated(metaView);
    }
  }

  @Override
  public String createXml(StudioChart studioChart, Map<String, Object> queryMap) {
    Map<String, Object> binding = new HashMap<>();
    binding.put("query", queryMap);
    binding.put("name", studioChart.getName());
    binding.put("title", studioChart.getTitle());
    binding.put("searchFieldsNotEmpty", !searchFields.isEmpty());

    if (!searchFields.isEmpty()) {
      binding.put("searchFields", searchFields);
    }

    String groupLabel =
        studioChart.getIsJsonGroupOn()
            ? studioChart.getGroupOnJson().getTitle()
            : studioChart.getGroupOn().getLabel();

    String displayLabel =
        studioChart.getIsJsonDisplayField()
            ? studioChart.getDisplayFieldJson().getTitle()
            : studioChart.getDisplayField().getLabel();

    binding.put("categoryType", categType);
    binding.put("categoryTitle", groupLabel);
    binding.put("seriesType", studioChart.getChartType());
    binding.put("seriesTitle", displayLabel);
    binding.put(
        "clickHandlerSupported",
        CLICK_HANDLER_SUPPORTED_CHARTS.contains(studioChart.getChartType()));

    return groovyTemplateService.createXmlWithGroovyTemplate(TEMPLATE_PATH, binding);
  }

  /**
   * Method create query from chart filters added in chart builder.
   *
   * @param studioChart StudioChart to use.
   * @return <String, Object> Map with the binding of query values to be used in the groovy template
   */
  @Override
  public Map<String, Object> prepareQuery(StudioChart studioChart) {

    Map<String, Object> queryMap = new HashMap<>();
    String sumField =
        getSumField(
            studioChart.getIsJsonDisplayField(),
            studioChart.getDisplayField(),
            studioChart.getDisplayFieldJson());

    String groupField =
        getGroup(
            studioChart.getIsJsonGroupOn(),
            studioChart.getGroupOn(),
            studioChart.getGroupOnJson(),
            studioChart.getGroupDateType(),
            studioChart.getGroupOnTarget());

    String aggField =
        getGroup(
            studioChart.getIsJsonAggregateOn(),
            studioChart.getAggregateOn(),
            studioChart.getAggregateOnJson(),
            studioChart.getAggregateDateType(),
            studioChart.getAggregateOnTarget());

    queryMap.put("sumField", sumField);
    queryMap.put("groupFieldNotNull", groupField != null);
    queryMap.put("groupField", groupField);
    if (aggField != null) {
      queryMap.put("aggField", aggField);
    }

    String filters = filterSqlService.getSqlFilters(studioChart.getFilterList(), joins, true);
    addSearchField(studioChart.getFilterList());
    String model = studioChart.getModel();

    queryMap.put("chartIsJson", studioChart.getIsJson());
    queryMap.put("filtersNotNull", filters != null);
    if (filters != null) {
      queryMap.put("filters", filters);
    }

    if (studioChart.getIsJson()) {
      queryMap.put("model", model);
      model = MetaJsonRecord.class.getName();
    }

    queryMap.put("tableName", getTable(model));

    if (!joins.isEmpty()) {
      queryMap.put("joins", Joiner.on(Tab3).join(joins));
    }

    queryMap.put("aggFieldNotNull", aggField != null);

    return queryMap;
  }

  @Override
  public String getSumField(boolean isJson, MetaField metaField, MetaJsonField jsonField) {
    return isJson
        ? "cast(self."
            + filterSqlService.getColumn(jsonField.getModel(), jsonField.getModelField())
            + "->>'"
            + jsonField.getName()
            + "' as "
            + filterSqlService.getSqlType(jsonField.getType())
            + ")"
        : "self." + filterSqlService.getColumn(metaField);
  }

  @Override
  public String getGroup(
      boolean isJson,
      MetaField metaField,
      MetaJsonField jsonField,
      String dateType,
      String target) {

    if (!isJson && metaField == null || isJson && jsonField == null) {
      return null;
    }

    String typeName;
    String group;
    Object object = null;
    StringBuilder parent = new StringBuilder("self");
    if (isJson) {
      group = jsonField.getName();
      typeName = filterSqlService.getSqlType(jsonField.getType());
      if (target != null) {
        object = filterSqlService.parseJsonField(jsonField, target, joins, parent);
      }
    } else {
      group = filterSqlService.getColumn(metaField);
      typeName = filterSqlService.getSqlType(metaField.getTypeName());
      if (target != null) {
        object = filterSqlService.parseMetaField(metaField, target, joins, parent, true);
      }
    }

    if (object != null) {
      String[] sqlField = filterSqlService.getSqlField(object, parent.toString(), joins);
      typeName = sqlField[1];
      group = sqlField[0];
    }

    log.debug("Group field type: {}, group: {}, dateType: {}", typeName, group, dateType);

    if (dateType != null && typeName != null && dateTypes.contains(typeName.toUpperCase())) {
      group = getDateTypeGroup(dateType, typeName, group);
    }

    return group;
  }

  @Override
  public String getDateTypeGroup(String dateType, String typeName, String group) {

    switch (dateType) {
      case "year":
        group = "to_char(cast(" + group + " as date), 'yyyy')";
        break;
      case "month":
        group = "to_char(cast(" + group + " as date), 'yyyy-mm')";
        break;
      default:
        categType = "date";
    }

    return group;
  }

  @Override
  public void addSearchField(List<Filter> filters) {

    if (filters == null) {
      return;
    }

    filters.stream()
        .filter(Filter::getIsParameter)
        .forEach(
            filter -> {
              HashMap<String, Object> searchFieldMap = new HashMap<>();
              String fieldStr = "param" + filter.getId();

              StringBuilder parent = new StringBuilder("self");

              Object object =
                  filter.getIsJson()
                      ? filterSqlService.parseJsonField(
                          filter.getMetaJsonField(), filter.getTargetField(), null, parent)
                      : filterSqlService.parseMetaField(
                          filter.getMetaField(), filter.getTargetField(), null, parent, true);

              if (object instanceof MetaField metaField) {
                searchFieldMap = getMetaSearchField(fieldStr, metaField, searchFieldMap);
              } else {
                searchFieldMap =
                    getJsonSearchField(fieldStr, (MetaJsonField) object, searchFieldMap);
              }

              searchFields.add(searchFieldMap);
            });
  }

  @Override
  public HashMap<String, Object> getMetaSearchField(
      String fieldStr, MetaField field, HashMap<String, Object> searchFieldMap) {

    searchFieldMap.put("name", fieldStr);
    searchFieldMap.put("title", field.getLabel());
    searchFieldMap.put("hasRelationship", field.getRelationship() != null);

    if (field.getRelationship() == null) {
      String fieldType = filterCommonService.getFieldType(field);
      searchFieldMap.put("type", fieldType);
    } else {
      String[] targetRef = filterSqlService.getDefaultTarget(field.getName(), field.getTypeName());
      String[] nameField = targetRef[0].split("\\.");
      searchFieldMap.put("type", filterCommonService.getFieldType(targetRef[1]));
      searchFieldMap.put("targetName", nameField[1]);
      searchFieldMap.put("target", metaModelRepo.findByName(field.getTypeName()).getFullName());
    }
    return searchFieldMap;
  }

  @Override
  public HashMap<String, Object> getJsonSearchField(
      String fieldStr, MetaJsonField field, HashMap<String, Object> searchFieldMap) {

    searchFieldMap.put("name", fieldStr);
    searchFieldMap.put("title", field.getTitle());

    if (field.getTargetJsonModel() != null) {
      String[] targetRef =
          filterSqlService.getDefaultTargetJson(field.getName(), field.getTargetJsonModel());
      String[] nameField = targetRef[0].split("\\.");
      searchFieldMap.put("type", filterCommonService.getFieldType(targetRef[1]));
      searchFieldMap.put("targetName", nameField[1]);
      searchFieldMap.put("target", MetaJsonRecord.class.getName());
      searchFieldMap.put(
          "xDomain", "self.jsonModel = '" + field.getTargetJsonModel().getName() + "'");
    } else if (field.getTargetModel() != null) {
      String[] targetRef =
          filterSqlService.getDefaultTarget(field.getName(), field.getTargetModel());
      String[] nameField = targetRef[0].split("\\.");
      searchFieldMap.put("type", filterCommonService.getFieldType(targetRef[1]));
      searchFieldMap.put("targetName", nameField[1]);
      searchFieldMap.put("target", field.getTargetModel());
    } else {
      String fieldType = Inflector.getInstance().camelize(field.getType(), true);
      searchFieldMap.put("type", fieldType);
    }

    return searchFieldMap;
  }

  @Override
  public String getTable(String model) {

    String[] models = model.split("\\.");
    MetaModel metaModel = metaModelRepo.findByName(models[models.length - 1]);

    if (metaModel != null) {
      return metaModel.getTableName();
    }

    return null;
  }

  @Override
  @CallMethod
  public String getDefaultTarget(MetaField metaField) {

    if (metaField.getRelationship() == null) {
      return metaField.getName();
    }

    return filterSqlService.getDefaultTarget(metaField.getName(), metaField.getTypeName())[0];
  }

  @Override
  @CallMethod
  public String getDefaultTarget(MetaJsonField metaJsonField) {

    if (!Arrays.asList(MANY_TO_ONE, ONE_TO_ONE, JSON_MANY_TO_ONE)
        .contains(metaJsonField.getType())) {
      return metaJsonField.getName();
    }

    if (metaJsonField.getTargetJsonModel() != null) {
      return filterSqlService
          .getDefaultTargetJson(metaJsonField.getName(), metaJsonField.getTargetJsonModel())[0];
    }

    if (metaJsonField.getTargetModel() == null) {
      return metaJsonField.getName();
    }

    return filterSqlService
        .getDefaultTarget(metaJsonField.getName(), metaJsonField.getTargetModel())[0];
  }

  @Override
  @CallMethod
  public String getTargetType(Object object, String target) {

    if (target == null) {
      log.debug("No target provided for target type");
      return null;
    }

    Object targetField = null;
    try {
      if (object instanceof MetaJsonField metaJsonField) {
        targetField = filterSqlService.parseJsonField(metaJsonField, target, null, null);
      } else if (object instanceof MetaField metaField) {
        targetField = filterSqlService.parseMetaField(metaField, target, null, null, true);
      }
    } catch (Exception e) {
    }

    if (targetField == null) {
      log.debug("Target field not found");
      return null;
    }

    log.debug("Target field found: {}", targetField);

    return filterSqlService.getTargetType(targetField);
  }
}
